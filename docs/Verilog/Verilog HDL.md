---
date: 2025-02-23
aliases:
  - Verilog Digital Design
tags:
  - 编程
  - normal
---
## Verilog基本结构
模块结构基本语法如下
```
module <模块名>(<端口列表>)
	参数定义(可选)
	端口说明(input, output, inout)
	数据类型说明
	持续赋值语句(assign)
	过程块(always initial)-行为描述语句
	底层模块实例-调用底层模块
	任务和函数
	演示说明模块
endmodule
```

## Verilog基础知识
### 词法
#### 间隔符
空格、制表符、换行以及换页符

#### 注释符
```
单行注释:以"//"起始，以新的一行作为结束
多行注释:以"/*"起始，以"*/"结束
```

#### 标识符
标识符可以是==字母、数字、符号"`$`和下划线"`_`==的任意组合序列，但它必须以字母(大小写)或下划线开头，不能是数字或`$`符开头。

#### 关键字
保留字，它是Verilog HDL的专用字，所有关键字都是用小写形式，不能将关键字用作标识符。
![[微信图片_20250223223957.jpg]]

### 常量
Verilog HDL有下列四种基本的值
1. 0：逻辑0或“假”。
2. 1：逻辑1或“真”。
3. x：不定值。
4. z：高组态。

#### 整数常量
在Verilog HDL中，整数有二进制(`b`或`B`)、八进制(`o`或`O`)、十六进制(`h`或`H`)或十进制(`d`或`D`)四种进制表示方式，格式为
```
<位宽>'<进制><数值>
```
其中位宽对应二进制数的位数，该项可选。当位宽小于相应数值的实际位数时，相应的高位部分被忽略；当位宽大于数值的实际位数，相应的高位部分补`0`(数值的最高位为`0`或`1`)或补`x`(数值的最高位为`x`)或补`z`(数值的最高位为`z`)。
- [!] `x`或`z`在十六进制中代表`4`位`x`(或`z`)，在八进制中代表三位`x`(或`z`)，在二进制中代表`1`位`x`(或`z`)，`x`(或`z`)不能出现在十进制中。
- [!] 数值常量中的下划线`_`是为了增加可读性，不会影响数值大小，但不能放在数值常量的首位。

#### 实数常量
##### 十进制计数法
```
2 . 0
5 . 678
0 . 1
//小数点两侧必须有一位数字
```
##### 科学计数法
```
23_5.1e2  //23510.0;下划线可忽略
3.6E2  //360.0
5 E-4  //0.0005
```

#### 字符串常量
字符串常量是一行写在双引号之间的字符串序列串，若字符串用作Verilog HDL表达式或操作数，则字符串被看作8位ASCII码值的序列，即一个字符对应8位ASCII码值。例如，字符串`"ab"`等价于`"16'h57_58"`。
字符串变量是寄存器型变量，它具有与字符串的字符数乘以8相等的位宽，如存储字符串`"Hello"`变量需要40位的寄存器。
支持转义符`\n、\t、\\、\'、\%`

### 数据类型和变量
#### wire型
`wire`型属连线型变量，对应的是硬件电路中的物理信号连线，没有电荷保持作用。它的值始终根据驱动的变化而更新。有两种方法对它进行驱动：一是在结构描述时把它连接到门或模块的输出端；二是用持续赋值语句`assign`语句对其进行赋值。如果没有驱动源对其赋值，连接型默认值位`z`。
`wire`型信号的定义格式如下： 
```
wire [msb:lsb] net1, net1, ···, net N;
```
其中，`msb` `lsb` 是用于定义连线型位宽的常量表达式；范围定义是可选的；==如果没有定义范围，缺省的为1位`wire`信号。==
```
wire a, b;  //定义两个1位的wire型变量a,b
wire [7:0] Addrbus;  //定义一个8位的wire型地址指向变量
```

#### reg型
`reg`型属于寄存器型变量，寄存器数据对应的是具有状态保持作用的硬件电路，如==触发器、锁存器==等。若寄存器的变量未被初始化，默认值为`x`。
与连线型之间的区别：==寄存器型数据保持最后一次赋值，而连线型数据需持续驱动==。
寄存器型数据只能在`always`语句和`initial`语句中被赋值。反之，在`always`语句和`initial`语句中被赋值的每一个信号必须定义为寄存器型。
```
reg [msb:lsb] reg1, reg2, ···;
```
`msb`和`lsb`定义了位宽，并且均为常量值表达式。范围定义是可选的；如果没有定义范围，缺省值为1为寄存器。例如：
```
reg [3:0] count;
reg a,b;
```
寄存器可以去任意长度。寄存器中的值通常被解释为无符号数，但寄存器的值可取负数，若该变量用于表达式的运算中，则按无符号数处理。

#### 存储型变量
存储型型变量为二位变量，由若干个相同位宽的向量构成，存储器型变量使用如下方式说明。
```
reg [msb:lsb] mem1 [upper1:lower1], mem2 [upper2:lower2], ···
wire [msb:lsb] mem1 [upper1:lower1], mem2 [upper2,lower2], ···
```

### 参数
用`parameter`语句来定义常量，即用`parameter`语句来定义一个标识符，代表一个常量，称为参数常量。参数经常用于定义时延和变量的宽度，来提高程序的可读性和可维护性。
==参数常量只能被赋值一次==，参数说明如下：
```
parameter counter_bits = 4;
```
在调用子模块时可通过参数传递的方法改变子模块内的参数值。

### 模块端口类型
1. `input`输入信号端口，在模块内不能对`input`信号赋值。
2. `output`输出信号端口。
3. `inout`双向`I/O`端口

### 运算符与优先级
#### 算数运算符
```
+ - * / %
```

- [!] 若某一操作数有不确定的值，则运算结果也是不确定的值。
- [!] 在进行整数除法运算时，结果值要略去小数部分，只取整数部分。

#### 关系运算符
```
> >= < <=
```

- [!] 若某一个操作数的值为不定`x`或高阻`z`，则关系是模糊的，返回值是不定值`x`。

#### 等式运算符
```
==  (相等)
!=  (不相等)
===  (全等)
!===  (非全等)
```

- [!] 在`==`和`!=`运算中，如果任何一个操作数中的某一位为不定值`x`或高阻`z`，则结果为不定值`x`。
- [!] 全等运算时将不定值`x`或高阻`z`看作是逻辑状态的一种参与比较，因此，全等运算返回的结果只有`0`和`1` 两种。

#### 逻辑运算符
```
!
&&
||
```

- [!] 同C语言

#### 按位逻辑运算符
```
~  (按位取反)
&  (按位与)
|  (按位或)
^  (按位异或)
^~ , ~^  (按位同或)
```

#### 缩位运算符
```
&  (缩位与)
~&  (缩位与非)
|  (缩位或)
~|  (缩位或非)
^  (缩位异或)
^~ , ~^  (缩位同或)
```

- [!] 缩位运算的运算过程是先将操作数的第一位与第二位进行与、或、非运算，然后将运算结果与第三位进行与、或、非运算，以此类推直至最后一位；最后的运算结果是一位的二进制数。

#### 位移运算符
```
A << n 或 A >> n
```

#### 条件运算符
```
? :
```

- [!] 同C语言

#### 位拼接运算符
```
{信号1的某几位，信号2的某几位，···,信号n的某几位}
```

#### 运算优先级
![[Verilog运算符优先级.jpg]]

## Verilog HDL的描述语句

### 数据流描述语句
数据流描述采用持续赋值语句即`assign`语句，它用于给`wire`等`nets`型变量进行赋值。当组合电路已有表达式或逻辑电路图，适合用`assign`语句描述。
全加器逻辑表达式如图
$$
\begin{cases}
s = a \oplus b \oplus c\\
co = a · b + a · ci + b · ci
\end{cases}
$$
```
module fulladder(a, b, c, ci, co);
	input a, b, ci;
	output s, co;
		 assign s = a ^ b ^ c;
         assign co = (a && ci) || (b && ci) || (a && b)
endmodule
```

- [!] 这些赋值语句是并发的，与其书写的顺序无关。只要持续赋值语句右端表达式中操作数的值变化，持续赋值语句即被执行。

### 行为描述语句
#### 过程结构
##### initial、always语句
一个模块中可以==包含多个==initial和always语句。这些语句==并行执行==，语句的执行顺序==与其在模块中的顺序无关==，都在0时刻开始并行执行。initial和always语句不能嵌套使用。
```
always语法如下
always @(<敏感信号表达式>)
begin
	//过程赋值
	//if语句
	//case语句
	//while、repeat、for语句
	//task、function调用
end
```

只要敏感信号表达式中的表达式的值发生变化，就会执行块内的语句。
敏感信号表达式列出所有影响块内变量取值的输入信号，若有两个或两个以上敏感信号时，它们之间用`or`连接。
```
always @(in0 or in1 or in2 or in3 or addr)
```

##### 串行语句块(begin···end语句组)
用来组合需要顺序执行中的语句。
##### 并行语句块(fork···join语句组)
用来组合需要并行执行中的语句。

initial过程赋值语句只执行一次，即在0时刻开始执行。
```
initial
    begin
     语句1；
     语句2；
     ···
    end
```

#### 过程赋值语句
##### 阻塞性过程赋值 “=”
表达式右端可以是任何表达式。在该语句结束时执行赋值，前面的语句没有完成前，后面的语句无法执行。顺序执行。
##### 非阻塞性过程赋值 “<=”
一条非阻塞赋值语句的执行是不会阻塞下一条语句的执行。在本条语句执行完毕前，下一条语句开始执行。

#### 条件分支语句
```
if(<条件表达式1>)语句或语句块1；
    else if(<条件表达式2>)语句或语句块2；
    ......
    else if(<条件表达式n>)语句或语句块n；
	else语句或语句块n+1；
```
条件表达式一般为逻辑表达式、关系表达式或1位逻辑变量。==若为0、不定值x、高阻z，作假处理；若为1，则为真。==

```
case(<控制表达式>)
	值1：语句或语句块1；
	值2：语句或语句块2；
	...
	值n：语句或语句块n；
	default：语句或语句块n+1；
endcase
```


#### 循环控制语句
```
for(循环变量赋初值；循环结束条件；循环变量增值)循环体语句或语句块；
```

```
n行串行加法器
module fulladder_n(a, b, s, ci, co);
parameter n = 4;
input [n-1:0] a;
input [n-1:0] b;
output [n-1:0] s;
input ci;
output co;
wire co;  //默认为一位的变量
integer i;
reg [n-1:0] s;
reg [n:0] c;
assign co = c[n];
always @(*)
begin
	c[0] = ci;
	for(i = 0; i <= n - 1; i = i + 1);
		begin
			s[i] = a[i] ^ b[i] ^ c[i];
			c[i + 1] = a[i] && b[i] || a[i] && c[i] || b[i]&&c[i];
		end
end
endmodule	
```

```
repeat(<循环次数表达式>)语句或语句块；
```

```
用repeat语句产生四变量组合电路的激励波形
initial
begin
	{a, b, c, d} = 0;
	repeat(16)begin #100 {a, b, c, d} = {a, b, c, d} + 1; end
	#100 $stop
end
```

### Verilog描述风格及层次化设计
#### 数据流型描述
#### 行为xing

